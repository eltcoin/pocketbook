const fs = require('fs');
const path = require('path');

const AUTOGEN_NOTICE = `// SPDX-License-Identifier: MIT\n// ---------------------------------------------------------------------------\n// This file was auto-generated by scripts/utils/generateBip39Vocabulary.js\n// Do not edit manually. Source: public/wordlists/bip39-english.txt\n// ---------------------------------------------------------------------------`;

function buildContractSource(words) {
  const joined = `${words.join('\n')}\n`;
  const hexPayload = Buffer.from(joined, 'utf8').toString('hex');

  return `${AUTOGEN_NOTICE}
pragma solidity ^0.8.20;

/// @notice Provides on-chain access to the standard BIP39 English vocabulary.
contract Bip39Vocabulary {
    uint16 public constant WORD_COUNT = ${words.length};
    bytes constant WORD_BYTES = hex"${hexPayload}";

    error WordOutOfBounds();

    /// @notice Returns the handle phrase at the provided index.
    function word(uint16 index) public pure returns (string memory) {
        if (index >= WORD_COUNT) revert WordOutOfBounds();
        return _toString(_wordBytes(index));
    }

    /// @notice Returns a slice of words for pagination (up to \`limit\`).
    function words(uint16 offset, uint16 limit) public pure returns (string[] memory) {
        if (offset >= WORD_COUNT) {
            return new string[](0);
        }

        uint16 capped = limit;
        if (offset + capped > WORD_COUNT) {
            capped = WORD_COUNT - offset;
        }
        string[] memory results = new string[](capped);
        for (uint16 i = 0; i < capped; ++i) {
            results[i] = _toString(_wordBytes(offset + i));
        }
        return results;
    }

    /// @notice Raw 32-byte representation for on-chain consumers.
    function wordBytes(uint16 index) public pure returns (bytes32) {
        if (index >= WORD_COUNT) revert WordOutOfBounds();
        return _wordBytes(index);
    }

    function _wordBytes(uint16 index) private pure returns (bytes32 result) {
        (uint256 start, uint256 length) = _locate(index);
        bytes memory data = WORD_BYTES;
        for (uint256 i; i < 32; ++i) {
            if (i < length) {
                result |= bytes32(uint256(uint8(data[start + i])) << (248 - i * 8));
            } else {
                break;
            }
        }
    }

    function _toString(bytes32 data) private pure returns (string memory) {
        uint256 length;
        while (length < 32 && data[length] != 0) {
            unchecked {
                ++length;
            }
        }

        bytes memory buffer = new bytes(length);
        for (uint256 i = 0; i < length; ++i) {
            buffer[i] = data[i];
        }
        return string(buffer);
    }

    function _locate(uint16 target) private pure returns (uint256 start, uint256 length) {
        bytes memory data = WORD_BYTES;
        uint16 current;
        uint256 cursor;
        uint256 lastStart;

        while (cursor < data.length) {
            if (data[cursor] == 0x0a) {
                if (current == target) {
                    return (lastStart, cursor - lastStart);
                }
                lastStart = cursor + 1;
                unchecked {
                    ++current;
                }
            }
            unchecked {
                ++cursor;
            }
        }

        if (current == target && lastStart < data.length) {
            return (lastStart, data.length - lastStart);
        }

        revert WordOutOfBounds();
    }
}
`;
}

function validateWords(words) {
  if (words.length === 0) {
    throw new Error('BIP39 wordlist file is empty.');
  }
  words.forEach((word, idx) => {
    if (!/^[a-z]+$/.test(word)) {
      throw new Error(`Invalid word "${word}" at line ${idx + 1}. Only lowercase ASCII is supported.`);
    }
    if (word.length > 32) {
      throw new Error(`Word "${word}" exceeds 32 bytes, cannot encode as bytes32.`);
    }
  });
}

function generateBip39Vocabulary({ rootDir }) {
  const wordlistPath = path.join(rootDir, 'public', 'wordlists', 'bip39-english.txt');
  if (!fs.existsSync(wordlistPath)) {
    throw new Error(`Wordlist not found at ${wordlistPath}`);
  }

  const source = fs.readFileSync(wordlistPath, 'utf8');
  const words = source
    .split(/\r?\n/)
    .map((word) => word.trim())
    .filter(Boolean);

  validateWords(words);

  const generatedDir = path.join(rootDir, 'contracts', 'generated');
  if (!fs.existsSync(generatedDir)) {
    fs.mkdirSync(generatedDir, { recursive: true });
  }

  const outputPath = path.join(generatedDir, 'Bip39Vocabulary.sol');
  const contractSource = buildContractSource(words);

  const previous = fs.existsSync(outputPath) ? fs.readFileSync(outputPath, 'utf8') : '';
  if (previous === contractSource) {
    return false;
  }

  fs.writeFileSync(outputPath, contractSource, 'utf8');
  return true;
}

module.exports = {
  generateBip39Vocabulary
};
